<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Visualizador 3D - Revit Elements</title>
    <style>
        body { margin: 0; font-family: Arial; }
        #container { display: flex; }
        #viewer { width: 70vw; height: 100vh; }
        #panel { width: 30vw; padding: 20px; overflow-y: auto; background: #f5f5f5; }
        .element-item { padding: 10px; margin: 5px; background: white; cursor: pointer; }
        .element-item:hover { background: #e0e0e0; }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/GLTFLoader.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tweenjs/tween.js@18.6.4/dist/tween.umd.min.js"></script>
</head>
<body>
    <div id="container">
        <div id="viewer"></div>
        <div id="panel">
            <h2>Elementos Revit</h2>
            <div id="elements-list"></div>
        </div>
    </div>

    <script>
        // 1. CONFIGURAÇÃO BÁSICA
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(document.getElementById('viewer').clientWidth, document.getElementById('viewer').clientHeight);
        document.getElementById('viewer').appendChild(renderer.domElement);

        // 2. DADOS DOS ELEMENTOS REVIT
        const revitElements = [];
        const elementProperties = {};

        // 3. FUNÇÃO PARA EXTRAIR METADADOS REVIT
        function extractRevitMetadata(object) {
            // Padrões comuns de exportação Revit para GLTF
            const metadataPatterns = [
                { pattern: /^(.*?) \[(.*?)\]$/, matches: ['familyType', 'elementId'] }, // Ex: "Wall [12345]"
                { pattern: /^(.*?) : (.*?) : (.*?)$/, matches: ['category', 'family', 'type'] }, // Ex: "Walls : Basic Wall : Generic - 200mm"
                { pattern: /^(.*?) - (.*?)$/, matches: ['family', 'type'] } // Ex: "Generic - 200mm"
            ];

            let metadata = {
                name: object.name,
                category: '',
                family: '',
                familyType: '',
                elementId: '',
                rawName: object.name
            };

            // Tenta extrair metadados dos padrões conhecidos
            for (const pattern of metadataPatterns) {
                const match = object.name.match(pattern.pattern);
                if (match) {
                    pattern.matches.forEach((prop, index) => {
                        metadata[prop] = match[index + 1].trim();
                    });
                    break;
                }
            }

            // Se não encontrou nos padrões, tenta extrair do userData
            if (object.userData && object.userData.revit) {
                metadata = { ...metadata, ...object.userData.revit };
            }

            return metadata;
        }

        // 4. CARREGAMENTO DO MODELO
        const loader = new THREE.GLTFLoader();
        loader.load(
            'modelo.glb',
            function(gltf) {
                console.log('Modelo carregado! Analisando elementos Revit...');
                
                // Processa todos os objetos na cena
                gltf.scene.traverse(function(child) {
                    if (child.isMesh) {
                        const revitData = extractRevitMetadata(child);
                        revitElements.push(revitData);
                        
                        // Armazena referência do objeto
                        elementProperties[child.name] = {
                            threeObj: child,
                            ...revitData
                        };
                    }
                });

                scene.add(gltf.scene);
                console.log('Elementos Revit identificados:', revitElements);
                
                // Atualiza a lista na UI
                updateElementsList();
                
                // Ajusta a câmera
                fitCameraToObject(gltf.scene);
            },
            undefined,
            function(error) {
                console.error('Erro ao carregar modelo:', error);
            }
        );

        // 5. FUNÇÃO PARA ATUALIZAR A LISTA DE ELEMENTOS
        function updateElementsList(filter = '') {
            const listContainer = document.getElementById('elements-list');
            listContainer.innerHTML = '';
            
            // Agrupa elementos por categoria/family
            const groupedElements = {};
            revitElements.forEach(element => {
                const groupKey = element.category || element.family || 'Outros';
                if (!groupedElements[groupKey]) {
                    groupedElements[groupKey] = [];
                }
                groupedElements[groupKey].push(element);
            });
            
            // Cria a UI agrupada
            for (const [group, elements] of Object.entries(groupedElements)) {
                const groupElement = document.createElement('div');
                groupElement.innerHTML = `<h3>${group}</h3>`;
                listContainer.appendChild(groupElement);
                
                elements.forEach(element => {
                    const item = document.createElement('div');
                    item.className = 'element-item';
                    item.innerHTML = `
                        <strong>${element.familyType || element.name}</strong><br>
                        <small>${element.family || ''} ${element.elementId ? `[${element.elementId}]` : ''}</small>
                    `;
                    
                    item.addEventListener('click', () => {
                        focusOnElement(element.name);
                    });
                    
                    listContainer.appendChild(item);
                });
            }
        }

        // 6. FUNÇÃO PARA FOCAR EM ELEMENTO
        function focusOnElement(elementName) {
            if (elementProperties[elementName]) {
                const element = elementProperties[elementName].threeObj;
                const bbox = new THREE.Box3().setFromObject(element);
                const center = bbox.getCenter(new THREE.Vector3());
                const size = bbox.getSize(new THREE.Vector3());
                
                // Animação da câmera
                new TWEEN.Tween(camera.position)
                    .to({
                        x: center.x,
                        y: center.y + size.y * 0.5,
                        z: center.z + size.z * 2
                    }, 1000)
                    .easing(TWEEN.Easing.Quadratic.Out)
                    .start();
                
                // Destacar elemento
                element.material.emissive.setHex(0x888888);
                setTimeout(() => {
                    element.material.emissive.setHex(0x000000);
                }, 2000);
                
                console.log('Elemento selecionado:', elementProperties[elementName]);
            }
        }

        // 7. FUNÇÃO PARA AJUSTAR CÂMERA
        function fitCameraToObject(object) {
            const bbox = new THREE.Box3().setFromObject(object);
            const center = bbox.getCenter(new THREE.Vector3());
            const size = bbox.getSize(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.y, size.z);
            
            camera.position.set(center.x, center.y, center.z + maxDim * 1.5);
            camera.lookAt(center);
        }

        // 8. ANIMAÇÃO
        function animate() {
            requestAnimationFrame(animate);
            TWEEN.update();
            renderer.render(scene, camera);
        }
        animate();

        // 9. COMUNICAÇÃO COM STREAMLIT
        window.addEventListener('message', function(event) {
            if (event.data.type === 'select-element') {
                focusOnElement(event.data.elementName);
            }
        });
    </script>
</body>
</html>
