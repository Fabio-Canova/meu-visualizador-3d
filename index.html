
<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Visualizador 3D - Elementos Revit</title>
    <style>
        body { margin: 0; overflow: hidden; }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.7);
            color: white;
            padding: 10px;
            font-family: Arial;
            font-size: 14px;
            border-radius: 5px;
            z-index: 100;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/GLTFLoader.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tweenjs/tween.js@18.6.4/dist/tween.umd.min.js"></script>
</head>
<body>
    <div id="info">Carregando modelo...</div>
    <script>
        // 1. CONFIGURAÇÃO BÁSICA
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x333333);
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // 2. CONTROLES E ILUMINAÇÃO
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
        scene.add(ambientLight);
        
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(5, 10, 7);
        scene.add(directionalLight);

        // 3. ESTRUTURA PARA ARMAZENAR ELEMENTOS REVIT
        window.revitElements = {
            all: [],
            byId: {},
            byFamily: {},
            byCategory: {},
            byType: {}
        };

        // 4. FUNÇÃO PARA EXTRAIR METADADOS REVIT
        function extractRevitMetadata(object) {
            // Verifica se já tem metadados no userData
            if (object.userData && object.userData.revit) {
                return object.userData.revit;
            }

            // Padrões de nomenclatura do Revit
            const patterns = [
                // Formato: "Family Type [ElementID]"
                { regex: /^(.*?)\s*\[([^\]]+)\]$/, props: ['familyType', 'elementId'] },
                
                // Formato: "Category:Family:Type"
                { regex: /^(.*?):(.*?):(.*?)$/, props: ['category', 'family', 'type'] },
                
                // Formato: "Family - Type"
                { regex: /^(.*?)\s*-\s*(.*?)$/, props: ['family', 'type'] }
            ];

            const metadata = {
                name: object.name,
                rawName: object.name,
                category: '',
                family: '',
                type: '',
                elementId: ''
            };

            // Tenta extrair dos padrões de nome
            for (const pattern of patterns) {
                const match = object.name.match(pattern.regex);
                if (match) {
                    pattern.props.forEach((prop, index) => {
                        metadata[prop] = match[index + 1].trim();
                    });
                    break;
                }
            }

            return metadata;
        }

        // 5. CARREGAMENTO DO MODELO
        const loader = new THREE.GLTFLoader();
        loader.load(
            'modelo.glb',
            function(gltf) {
                document.getElementById('info').textContent = "Modelo carregado!";
                console.log('Modelo carregado com sucesso!');
                
                // Processa todos os objetos
                gltf.scene.traverse(function(child) {
                    if (child.isMesh) {
                        const revitData = extractRevitMetadata(child);
                        
                        // Armazena o objeto
                        const element = {
                            threeObj: child,
                            ...revitData
                        };
                        
                        // Adiciona às estruturas de organização
                        window.revitElements.all.push(element);
                        window.revitElements.byId[revitData.elementId || child.uuid] = element;
                        
                        if (revitData.family) {
                            window.revitElements.byFamily[revitData.family] = 
                                window.revitElements.byFamily[revitData.family] || [];
                            window.revitElements.byFamily[revitData.family].push(element);
                        }
                        
                        if (revitData.category) {
                            window.revitElements.byCategory[revitData.category] = 
                                window.revitElements.byCategory[revitData.category] || [];
                            window.revitElements.byCategory[revitData.category].push(element);
                        }
                        
                        if (revitData.type) {
                            window.revitElements.byType[revitData.type] = 
                                window.revitElements.byType[revitData.type] || [];
                            window.revitElements.byType[revitData.type].push(element);
                        }
                        
                        console.log('Elemento Revit:', element);
                    }
                });

                scene.add(gltf.scene);
                
                // Ajusta a câmera
                const bbox = new THREE.Box3().setFromObject(gltf.scene);
                const center = bbox.getCenter(new THREE.Vector3());
                const size = bbox.getSize(new THREE.Vector3());
                const maxDim = Math.max(size.x, size.y, size.z);
                
                camera.position.set(center.x, center.y, center.z + maxDim * 1.5);
                controls.target.copy(center);
                controls.update();
                
                // Atualiza o painel de informações
                updateInfoPanel();
            },
            function(xhr) {
                const percent = Math.round((xhr.loaded / xhr.total) * 100);
                document.getElementById('info').textContent = `Carregando: ${percent}%`;
            },
            function(error) {
                document.getElementById('info').textContent = "Erro ao carregar modelo!";
                console.error('Erro ao carregar modelo:', error);
            }
        );

        // 6. FUNÇÃO PARA FOCAR EM ELEMENTO
        window.focusOnRevitElement = function(identifier) {
            let element;
            
            // Tenta encontrar por ID, nome, family ou type
            element = window.revitElements.byId[identifier] || 
                     window.revitElements.all.find(e => e.name === identifier) ||
                     window.revitElements.all.find(e => e.family === identifier) ||
                     window.revitElements.all.find(e => e.type === identifier);
            
            if (element) {
                const obj = element.threeObj;
                const bbox = new THREE.Box3().setFromObject(obj);
                const center = bbox.getCenter(new THREE.Vector3());
                const size = bbox.getSize(new THREE.Vector3());
                
                // Animação da câmera
                new TWEEN.Tween(camera.position)
                    .to({
                        x: center.x,
                        y: center.y + size.y * 0.5,
                        z: center.z + size.length() * 1.5
                    }, 1000)
                    .easing(TWEEN.Easing.Quadratic.Out)
                    .start();
                
                // Animação do target
                new TWEEN.Tween(controls.target)
                    .to(center, 1000)
                    .start();
                
                // Destaque visual temporário
                obj.material.emissive.setHex(0x888888);
                setTimeout(() => {
                    obj.material.emissive.setHex(0x000000);
                }, 2000);
                
                // Atualiza o painel de informações
                updateInfoPanel(element);
                
                return true;
            }
            
            console.warn('Elemento não encontrado:', identifier);
            return false;
        };

        // 7. PAINEL DE INFORMAÇÕES
        function updateInfoPanel(element = null) {
            const infoDiv = document.getElementById('info');
            
            if (element) {
                infoDiv.innerHTML = `
                    <strong>${element.name}</strong><br>
                    ${element.family ? `Family: ${element.family}<br>` : ''}
                    ${element.type ? `Type: ${element.type}<br>` : ''}
                    ${element.category ? `Category: ${element.category}<br>` : ''}
                    ${element.elementId ? `ID: ${element.elementId}` : ''}
                `;
            } else {
                const counts = {
                    families: Object.keys(window.revitElements.byFamily).length,
                    categories: Object.keys(window.revitElements.byCategory).length,
                    elements: window.revitElements.all.length
                };
                
                infoDiv.innerHTML = `
                    Modelo carregado:<br>
                    • ${counts.elements} elementos<br>
                    • ${counts.families} families<br>
                    • ${counts.categories} categorias
                `;
            }
        }

        // 8. ANIMAÇÃO
        function animate() {
            requestAnimationFrame(animate);
            TWEEN.update();
            controls.update();
            renderer.render(scene, camera);
        }
        animate();

        // 9. COMUNICAÇÃO COM STREAMLIT
        window.addEventListener('message', function(event) {
            if (event.data.type === 'select-element') {
                const success = window.focusOnRevitElement(event.data.elementName);
                
                // Resposta para Streamlit
                if (event.source) {
                    event.source.postMessage({
                        type: 'selection-response',
                        elementName: event.data.elementName,
                        success: success,
                        availableElements: window.revitElements.all.map(e => ({
                            name: e.name,
                            family: e.family,
                            type: e.type,
                            category: e.category,
                            id: e.elementId
                        }))
                    }, event.origin);
                }
            }
        });

        // 10. REDIMENSIONAMENTO
        window.addEventListener('resize', function() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
