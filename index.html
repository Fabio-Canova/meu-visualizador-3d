

<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Visualizador 3D Interativo</title>
    <style>
        body { margin: 0; overflow: hidden; }
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            background: rgba(0,0,0,0.7);
            padding: 20px;
            border-radius: 10px;
            font-family: Arial;
        }
    </style>
    <!-- Dependências -->
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/GLTFLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.132.2/examples/js/loaders/DRACOLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@tweenjs/tween.js@18.5.0/dist/tween.esm.js"></script>
    <script>
    // Cria alias global para compatibilidade
    if (typeof TWEEN === 'undefined' && typeof window.TWEEN !== 'undefined') {
        window.TWEEN = window.TWEEN;
    }
</script>
</head>
<body>
    <div id="loading">Carregando modelo...</div>

    <script>
        // 1. Configuração básica
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x222222);
        
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
        camera.position.z = 5;
        
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);
        
        // 2. Controles
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        
        // 3. Iluminação
        const light = new THREE.DirectionalLight(0xffffff, 1);
        light.position.set(1, 1, 1);
        scene.add(light);
        scene.add(new THREE.AmbientLight(0x404040));

        // 4. Loader com Draco
        const loader = new THREE.GLTFLoader();
        const dracoLoader = new THREE.DRACOLoader();
        dracoLoader.setDecoderPath('https://www.gstatic.com/draco/v1/decoders/');
        loader.setDRACOLoader(dracoLoader);

        // 5. Variáveis globais
        let model;
        const elementCache = {};
        const originalMaterials = {};
        let lastZoom = 1.0;

        // 6. Carregamento do modelo
        loader.load(
            './modelo.glb',
            (gltf) => {
                model = gltf.scene;
                scene.add(model);
                document.getElementById('loading').style.display = 'none';
                
                // Cache de elementos e materiais
                model.traverse((child) => {
                    if (child.isMesh) {
                        elementCache[child.name || child.uuid] = child;
                        originalMaterials[child.name || child.uuid] = child.material.clone();
                    }
                });
                
                // Notifica o Streamlit que o modelo está pronto
                if (window.parent !== window) {
                    window.parent.postMessage({
                        type: 'model-ready',
                        elements: Object.keys(elementCache).filter(Boolean)
                    }, '*');
                }
            },
            (xhr) => {
                const percent = (xhr.loaded / xhr.total * 100).toFixed(2);
                document.getElementById('loading').textContent = `Carregando... ${percent}%`;
            },
            (error) => {
                console.error('Erro:', error);
                document.getElementById('loading').innerHTML = `
                    Erro ao carregar modelo:<br>
                    <small>${error.message}</small>
                `;
            }
        );

        // 7. Funções de interação
        function focusOnElement(elementName, zoomLevel = 1.0) {
            if (!model || !elementCache[elementName]) return;
            
            lastZoom = zoomLevel;
            const element = elementCache[elementName];
            const box = new THREE.Box3().setFromObject(element);
            const center = box.getCenter(new THREE.Vector3());
            const size = box.getSize(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.y, size.z);
            const fov = camera.fov * (Math.PI / 180);
            const cameraZ = Math.abs(maxDim / (2 * Math.tan(fov / 2))) * zoomLevel;
            
            // Restaura materiais originais
            model.traverse((child) => {
                if (child.isMesh && originalMaterials[child.name || child.uuid]) {
                    child.material = originalMaterials[child.name || child.uuid].clone();
                }
            });
            
            // Destaque o elemento selecionado
            element.material.color.setHex(0xFFA500);
            
            // Animação suave
            new TWEEN.Tween(camera.position)
                .to({ 
                    x: center.x * 1.2, 
                    y: center.y * 1.2, 
                    z: center.z + cameraZ 
                }, 800)
                .easing(TWEEN.Easing.Quadratic.Out)
                .start();
                
            new TWEEN.Tween(controls.target)
                .to(center, 800)
                .easing(TWEEN.Easing.Quadratic.Out)
                .start();
        }

        function resetView() {
            new TWEEN.Tween(camera.position)
                .to({ x: 0, y: 0, z: 5 * lastZoom }, 800)
                .start();
                
            new TWEEN.Tween(controls.target)
                .to({ x: 0, y: 0, z: 0 }, 800)
                .start();
                
            // Restaura todos os materiais
            model.traverse((child) => {
                if (child.isMesh && originalMaterials[child.name || child.uuid]) {
                    child.material = originalMaterials[child.name || child.uuid].clone();
                }
            });
        }

        // 8. Comunicação com Streamlit
        window.addEventListener('message', (event) => {
            try {
                const data = event.data;
                
                switch(data.type) {
                    case 'select-element':
                        focusOnElement(data.elementName, data.zoom || 1.0);
                        break;
                        
                    case 'reset-view':
                        resetView();
                        break;
                        
                    case 'set-zoom':
                        lastZoom = data.value;
                        camera.position.z = 5 * data.value;
                        break;
                }
            } catch (error) {
                console.error('Erro no processamento:', error);
            }
        });

        // 9. Animação e redimensionamento
        function animate() {
            requestAnimationFrame(animate);
            TWEEN.update();
            controls.update();
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
